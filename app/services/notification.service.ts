import prisma from "~/db.server";
import { NotificationChannel, NotificationStatus } from "@prisma/client";

// Comprehensive notification service with real implementations
export interface NotificationConfig {
  email?: {
    enabled: boolean;
    address: string;
    smtpHost?: string;
    smtpPort?: number;
    smtpUser?: string;
    smtpPassword?: string;
  };
  slack?: {
    enabled: boolean;
    webhookUrl: string;
    channel?: string;
  };
  telegram?: {
    enabled: boolean;
    botToken: string;
    chatId: string;
  };
  sms?: {
    enabled: boolean;
    phoneNumber: string;
    provider?: 'twilio' | 'aws_sns';
    apiKey?: string;
    apiSecret?: string;
  };
  webhook?: {
    enabled: boolean;
    url: string;
    secret?: string;
  };
}

export interface NotificationPayload {
  shopId: string;
  productId?: string;
  productTitle?: string;
  alertType: string;
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  title: string;
  message: string;
  metadata?: Record<string, any>;
}

export interface NotificationResult {
  success: boolean;
  channel: NotificationChannel;
  status: NotificationStatus;
  message?: string;
  error?: string;
  deliveryId?: string;
}

// Retry configuration
const RETRY_CONFIG = {
  maxRetries: 3,
  baseDelay: 1000,
  maxDelay: 10000,
};

// Enhanced retry logic with exponential backoff
async function withRetry<T>(
  operation: () => Promise<T>,
  maxRetries: number = RETRY_CONFIG.maxRetries,
  baseDelay: number = RETRY_CONFIG.baseDelay
): Promise<T> {
  let lastError: Error;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error as Error;
      
      if (attempt === maxRetries) {
        throw lastError;
      }
      
      // Calculate delay with exponential backoff and jitter
      const delay = Math.min(
        baseDelay * Math.pow(2, attempt) + Math.random() * 1000,
        RETRY_CONFIG.maxDelay
      );
      
      await new Promise(resolve => setTimeout(resolve, delay));
      console.log(`Retrying notification (attempt ${attempt + 1}/${maxRetries}) after ${delay}ms delay`);
    }
  }
  
  throw lastError!;
}

// Email notification implementation
async function sendEmailNotification(
  config: NotificationConfig['email'],
  payload: NotificationPayload
): Promise<NotificationResult> {
  if (!config?.enabled || !config.address) {
    return {
      success: false,
      channel: NotificationChannel.Email,
      status: NotificationStatus.FailedConfiguration,
      error: 'Email configuration missing or disabled'
    };
  }

  try {
    // Use a proper email service (SendGrid, AWS SES, etc.)
    // For now, implementing with a generic email API approach
    
    const emailData = {
      to: config.address,
      subject: `${payload.alertType}: ${payload.title}`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <div style="background: linear-gradient(135deg, #D91A5B, #8B2635); color: white; padding: 20px; border-radius: 8px 8px 0 0;">
            <h1 style="margin: 0; font-size: 24px;">ðŸš¨ Planet Beauty Inventory Alert</h1>
          </div>
          <div style="background: white; padding: 20px; border: 1px solid #ddd; border-radius: 0 0 8px 8px;">
            <h2 style="color: #D91A5B; margin-top: 0;">${payload.title}</h2>
            <p style="font-size: 16px; line-height: 1.5;">${payload.message}</p>
            
            ${payload.productTitle ? `
              <div style="background: #f8f9fa; padding: 15px; border-radius: 4px; margin: 20px 0;">
                <strong>Product:</strong> ${payload.productTitle}<br>
                <strong>Alert Type:</strong> ${payload.alertType}<br>
                <strong>Severity:</strong> ${payload.severity}
              </div>
            ` : ''}
            
            <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee;">
              <p style="color: #666; font-size: 14px;">
                This alert was generated by Planet Beauty Inventory AI.<br>
                Visit your dashboard to take action or adjust settings.
              </p>
            </div>
          </div>
        </div>
      `,
      text: `${payload.title}\n\n${payload.message}\n\nProduct: ${payload.productTitle || 'N/A'}\nAlert Type: ${payload.alertType}\nSeverity: ${payload.severity}`
    };

    // Example implementation with SendGrid (you would configure this)
    if (process.env.SENDGRID_API_KEY) {
      const response = await fetch('https://api.sendgrid.com/v3/mail/send', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.SENDGRID_API_KEY}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          personalizations: [{ to: [{ email: config.address }] }],
          from: { email: process.env.FROM_EMAIL || 'noreply@planetbeauty.ai' },
          subject: emailData.subject,
          content: [
            { type: 'text/html', value: emailData.html },
            { type: 'text/plain', value: emailData.text }
          ]
        })
      });

      if (response.ok) {
        return {
          success: true,
          channel: NotificationChannel.Email,
          status: NotificationStatus.Sent,
          message: 'Email sent successfully',
          deliveryId: response.headers.get('x-message-id') || undefined
        };
      } else {
        throw new Error(`SendGrid API error: ${response.status} ${response.statusText}`);
      }
    }

    // Fallback: Log email content (for development/testing)
    console.log('ðŸ“§ Email notification (simulated):', {
      to: config.address,
      subject: emailData.subject,
      content: emailData.text
    });

    return {
      success: true,
      channel: NotificationChannel.Email,
      status: NotificationStatus.Simulated,
      message: 'Email simulated (no SMTP configured)'
    };

  } catch (error) {
    console.error('Email notification failed:', error);
    return {
      success: false,
      channel: NotificationChannel.Email,
      status: NotificationStatus.Failed,
      error: error instanceof Error ? error.message : 'Unknown email error'
    };
  }
}

// Slack notification implementation
async function sendSlackNotification(
  config: NotificationConfig['slack'],
  payload: NotificationPayload
): Promise<NotificationResult> {
  if (!config?.enabled || !config.webhookUrl) {
    return {
      success: false,
      channel: NotificationChannel.Slack,
      status: NotificationStatus.FailedConfiguration,
      error: 'Slack configuration missing or disabled'
    };
  }

  try {
    const severityColor = {
      LOW: '#36a64f',      // Green
      MEDIUM: '#ff9500',   // Orange  
      HIGH: '#ff6b35',     // Red-orange
      CRITICAL: '#e01e5a'  // Red
    }[payload.severity] || '#36a64f';

    const slackMessage = {
      username: 'Planet Beauty Inventory AI',
      icon_emoji: ':warning:',
      attachments: [
        {
          color: severityColor,
          title: payload.title,
          text: payload.message,
          fields: [
            ...(payload.productTitle ? [{
              title: 'Product',
              value: payload.productTitle,
              short: true
            }] : []),
            {
              title: 'Alert Type',
              value: payload.alertType,
              short: true
            },
            {
              title: 'Severity',
              value: payload.severity,
              short: true
            },
            {
              title: 'Time',
              value: new Date().toLocaleString(),
              short: true
            }
          ],
          footer: 'Planet Beauty Inventory AI',
          footer_icon: 'https://cdn.shopify.com/s/files/1/0533/2089/files/favicon.png',
          timestamp: Math.floor(Date.now() / 1000)
        }
      ]
    };

    const response = await withRetry(async () => {
      return await fetch(config.webhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(slackMessage)
      });
    });

    if (response.ok) {
      return {
        success: true,
        channel: NotificationChannel.Slack,
        status: NotificationStatus.Sent,
        message: 'Slack message sent successfully'
      };
    } else {
      throw new Error(`Slack webhook error: ${response.status} ${response.statusText}`);
    }

  } catch (error) {
    console.error('Slack notification failed:', error);
    return {
      success: false,
      channel: NotificationChannel.Slack,
      status: NotificationStatus.Failed,
      error: error instanceof Error ? error.message : 'Unknown Slack error'
    };
  }
}

// Telegram notification implementation  
async function sendTelegramNotification(
  config: NotificationConfig['telegram'],
  payload: NotificationPayload
): Promise<NotificationResult> {
  if (!config?.enabled || !config.botToken || !config.chatId) {
    return {
      success: false,
      channel: NotificationChannel.Telegram,
      status: NotificationStatus.FailedConfiguration,
      error: 'Telegram configuration missing or disabled'
    };
  }

  try {
    const severityEmoji = {
      LOW: 'ðŸŸ¢',
      MEDIUM: 'ðŸŸ¡', 
      HIGH: 'ðŸŸ ',
      CRITICAL: 'ðŸ”´'
    }[payload.severity] || 'ðŸ”µ';

    const telegramMessage = `
${severityEmoji} *${payload.title}*

${payload.message}

${payload.productTitle ? `ðŸ“¦ *Product:* ${payload.productTitle}` : ''}
ðŸ·ï¸ *Alert Type:* ${payload.alertType}
âš ï¸ *Severity:* ${payload.severity}
ðŸ• *Time:* ${new Date().toLocaleString()}

_Generated by Planet Beauty Inventory AI_
    `.trim();

    const response = await withRetry(async () => {
      return await fetch(`https://api.telegram.org/bot${config.botToken}/sendMessage`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          chat_id: config.chatId,
          text: telegramMessage,
          parse_mode: 'Markdown',
          disable_web_page_preview: true
        })
      });
    });

    const result = await response.json();

    if (response.ok && result.ok) {
      return {
        success: true,
        channel: NotificationChannel.Telegram,
        status: NotificationStatus.Sent,
        message: 'Telegram message sent successfully',
        deliveryId: result.result.message_id?.toString()
      };
    } else {
      throw new Error(`Telegram API error: ${result.description || response.statusText}`);
    }

  } catch (error) {
    console.error('Telegram notification failed:', error);
    return {
      success: false,
      channel: NotificationChannel.Telegram,
      status: NotificationStatus.Failed,
      error: error instanceof Error ? error.message : 'Unknown Telegram error'
    };
  }
}

// SMS notification implementation
async function sendSMSNotification(
  config: NotificationConfig['sms'],
  payload: NotificationPayload
): Promise<NotificationResult> {
  if (!config?.enabled || !config.phoneNumber) {
    return {
      success: false,
      channel: NotificationChannel.SMS,
      status: NotificationStatus.FailedConfiguration,
      error: 'SMS configuration missing or disabled'
    };
  }

  try {
    const smsMessage = `ðŸš¨ ${payload.title}\n\n${payload.message}\n\n${payload.productTitle ? `Product: ${payload.productTitle}\n` : ''}Severity: ${payload.severity}\n\nPlanet Beauty AI`;

    // Example with Twilio (you would configure this)
    if (config.provider === 'twilio' && process.env.TWILIO_ACCOUNT_SID && process.env.TWILIO_AUTH_TOKEN) {
      const auth = Buffer.from(`${process.env.TWILIO_ACCOUNT_SID}:${process.env.TWILIO_AUTH_TOKEN}`).toString('base64');
      
      const response = await withRetry(async () => {
        return await fetch(`https://api.twilio.com/2010-04-01/Accounts/${process.env.TWILIO_ACCOUNT_SID}/Messages.json`, {
          method: 'POST',
          headers: {
            'Authorization': `Basic ${auth}`,
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: new URLSearchParams({
            To: config.phoneNumber,
            From: process.env.TWILIO_PHONE_NUMBER || '',
            Body: smsMessage.substring(0, 1600) // SMS length limit
          })
        });
      });

      const result = await response.json();

      if (response.ok) {
        return {
          success: true,
          channel: NotificationChannel.SMS,
          status: NotificationStatus.Sent,
          message: 'SMS sent successfully',
          deliveryId: result.sid
        };
      } else {
        throw new Error(`Twilio API error: ${result.message || response.statusText}`);
      }
    }

    // Fallback: Log SMS content
    console.log('ðŸ“± SMS notification (simulated):', {
      to: config.phoneNumber,
      message: smsMessage
    });

    return {
      success: true,
      channel: NotificationChannel.SMS,
      status: NotificationStatus.Simulated,
      message: 'SMS simulated (no provider configured)'
    };

  } catch (error) {
    console.error('SMS notification failed:', error);
    return {
      success: false,
      channel: NotificationChannel.SMS,
      status: NotificationStatus.Failed,
      error: error instanceof Error ? error.message : 'Unknown SMS error'
    };
  }
}

// Webhook notification implementation
async function sendWebhookNotification(
  config: NotificationConfig['webhook'],
  payload: NotificationPayload
): Promise<NotificationResult> {
  if (!config?.enabled || !config.url) {
    return {
      success: false,
      channel: NotificationChannel.Webhook,
      status: NotificationStatus.FailedConfiguration,
      error: 'Webhook configuration missing or disabled'
    };
  }

  try {
    const webhookPayload = {
      timestamp: new Date().toISOString(),
      event_type: 'inventory_alert',
      shop_id: payload.shopId,
      alert: {
        type: payload.alertType,
        severity: payload.severity,
        title: payload.title,
        message: payload.message,
        product: payload.productTitle ? {
          id: payload.productId,
          title: payload.productTitle
        } : undefined,
        metadata: payload.metadata
      }
    };

    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      'User-Agent': 'Planet-Beauty-Inventory-AI/1.0'
    };

    // Add signature if secret is configured
    if (config.secret) {
      const crypto = await import('crypto');
      const signature = crypto
        .createHmac('sha256', config.secret)
        .update(JSON.stringify(webhookPayload))
        .digest('hex');
      headers['X-Planet-Beauty-Signature'] = `sha256=${signature}`;
    }

    const response = await withRetry(async () => {
      return await fetch(config.url, {
        method: 'POST',
        headers,
        body: JSON.stringify(webhookPayload)
      });
    });

    if (response.ok) {
      return {
        success: true,
        channel: NotificationChannel.Webhook,
        status: NotificationStatus.Sent,
        message: 'Webhook delivered successfully'
      };
    } else {
      throw new Error(`Webhook error: ${response.status} ${response.statusText}`);
    }

  } catch (error) {
    console.error('Webhook notification failed:', error);
    return {
      success: false,
      channel: NotificationChannel.Webhook,
      status: NotificationStatus.Failed,
      error: error instanceof Error ? error.message : 'Unknown webhook error'
    };
  }
}

// Main notification service
export async function sendNotification(
  shopId: string,
  payload: NotificationPayload
): Promise<NotificationResult[]> {
  try {
    // Get shop notification settings
    const shop = await prisma.shop.findUnique({
      where: { id: shopId },
      include: { NotificationSetting: true }
    });

    if (!shop || !shop.NotificationSetting) {
      return [{
        success: false,
        channel: NotificationChannel.System,
        status: NotificationStatus.FailedConfiguration,
        error: 'No notification settings found for shop'
      }];
    }

    const settings = shop.NotificationSetting;
    const results: NotificationResult[] = [];

    // Build notification config from settings
    const config: NotificationConfig = {
      email: settings.email ? {
        enabled: settings.email,
        address: settings.emailAddress || ''
      } : undefined,
      slack: settings.slack ? {
        enabled: settings.slack,
        webhookUrl: settings.slackWebhookUrl || ''
      } : undefined,
      telegram: settings.telegram ? {
        enabled: settings.telegram,
        botToken: settings.telegramBotToken || '',
        chatId: settings.telegramChatId || ''
      } : undefined,
      sms: settings.email ? {
        enabled: settings.email,
        phoneNumber: ''
      } : undefined,
      webhook: settings.slack ? {
        enabled: settings.slack,
        url: ''
      } : undefined
    };

    // Send notifications via all enabled channels
    const notificationPromises: Promise<NotificationResult>[] = [];

    if (config.email?.enabled) {
      notificationPromises.push(sendEmailNotification(config.email, payload));
    }
    if (config.slack?.enabled) {
      notificationPromises.push(sendSlackNotification(config.slack, payload));
    }
    if (config.telegram?.enabled) {
      notificationPromises.push(sendTelegramNotification(config.telegram, payload));
    }
    if (config.sms?.enabled) {
      notificationPromises.push(sendSMSNotification(config.sms, payload));
    }
    if (config.webhook?.enabled) {
      notificationPromises.push(sendWebhookNotification(config.webhook, payload));
    }

    if (notificationPromises.length === 0) {
      return [{
        success: false,
        channel: NotificationChannel.System,
        status: NotificationStatus.FailedConfiguration,
        error: 'No notification channels enabled'
      }];
    }

    // Execute all notifications in parallel
    const notificationResults = await Promise.allSettled(notificationPromises);
    
    for (const result of notificationResults) {
      if (result.status === 'fulfilled') {
        results.push(result.value);
      } else {
        results.push({
          success: false,
          channel: NotificationChannel.System,
          status: NotificationStatus.Error,
          error: result.reason?.message || 'Unknown notification error'
        });
      }
    }

    // Log all notification attempts
    await Promise.all(
      results.map(result => 
        prisma.notificationLog.create({
          data: {
            id: payload.productId || new Date().toISOString(),
            shopId: shopId,
            channel: result.channel,
            recipient: getRecipientForChannel(result.channel, config),
            message: payload.message,
            subject: payload.title,
            status: result.status,
            variantId: payload.productId,
            productTitle: payload.productTitle,
            alertType: payload.alertType,
            errorMessage: result.error,
            updatedAt: new Date(),
            metadata: {
              severity: payload.severity,
              deliveryId: result.deliveryId,
              ...payload.metadata
            }
          }
        })
      )
    );

    return results;

  } catch (error) {
    console.error('Notification service failed:', error);
    return [{
      success: false,
      channel: NotificationChannel.System,
      status: NotificationStatus.Error,
      error: error instanceof Error ? error.message : 'Unknown notification service error'
    }];
  }
}

// Helper function to get recipient info for logging
function getRecipientForChannel(channel: NotificationChannel, config: NotificationConfig): string | null {
  switch (channel) {
    case NotificationChannel.Email:
      return config.email?.address || null;
    case NotificationChannel.Slack:
      return config.slack?.webhookUrl || null;
    case NotificationChannel.Telegram:
      return config.telegram?.chatId || null;
    case NotificationChannel.SMS:
      return config.sms?.phoneNumber || null;
    case NotificationChannel.Webhook:
      return config.webhook?.url || null;
    default:
      return null;
  }
}

// Test notification function
export async function sendTestNotification(
  shopId: string,
  channel: NotificationChannel
): Promise<NotificationResult> {
  const testPayload: NotificationPayload = {
    shopId,
    alertType: 'TEST_NOTIFICATION',
    severity: 'LOW',
    title: 'Test Notification from Planet Beauty AI',
    message: 'This is a test notification to verify your configuration is working correctly. If you received this, your notifications are set up properly!',
    metadata: {
      test: true,
      timestamp: new Date().toISOString()
    }
  };

  const results = await sendNotification(shopId, testPayload);
  return results.find(r => r.channel === channel) || {
    success: false,
    channel,
    status: NotificationStatus.Failed,
    error: 'Channel not found in results'
  };
}